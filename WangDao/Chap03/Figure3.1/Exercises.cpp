#include "Stack.h"
#include "../../Chap02/Figure2.3/LinkedList.h"

// ------------------------------- 王道综合应用题 -------------------------------

/*-------------------------------------------------------------------------
 3. 假设以I和O分别表示入栈和出栈操作。栈的初态和终态均为空，入栈和出栈的操作序列可表示
 为仅由I和O组成的序列，可以操作的序列称为合法序列，否则称为非法序列。
 写一个算法，判定所给的操作序列是否合法。若合法，返回true，否则返回false(假定被判定的
 操作序列已存入一维数组中)。

 算法思想: 依次逐一扫描入栈出栈序列(即由"I"和"O"组成的字符串)，每扫描至任一位置均需检查
 出栈次数(即"O"的个数)是否小于入栈次数("I"的个数)，若大于则为非法序列。扫描结束后，再判
 断入栈和出栈次数是否相等，若不相等则不合题意，为非法序列。
 ------------------------------------------------------------------------*/
int judge(char A[]) {
    // 判断字符数组A中的输入输出序列是否是合法序列。如是，返回true，否则返回false
    int i = 0;          // i为下标
    int j = 0, k = 0;   // j和k分别为字母I和O的个数
    while (A[i] != '\0') {      // 未到字符数组末尾
        switch (A[i]) {
            case 'I':
                j++;
                break;   // 入栈次数增1
            case 'O':
                k++;
                if (k > j) {
                    printf("序列非法\n");
                    exit(0);
                }
        }
        i++;        // 不论A[i]是'I'或'O'，指针i均后移
    } // end of while
    if (j != k) {
        printf("序列非法\n");
        return false;
    } else {
        printf("序列合法\n");
        return true;
    }
}

/*-------------------------------------------------------------------------
 4. 设单链表的表头指针为L，结点结构由data和next两个域构成，其中data域为字符型。试设计
 算法判断该链表的全部n个字符是否中心对称。例如xyx、xyyx都是中心对称。

 算法思想: 使用栈来判断链表中的数据是否中心对称。让链表的前一半元素依次进栈。在处理链表
 的后一半元素时，当访问到链表的一个元素后，就从栈中弹出一个元素，两个元素比较，若相等，则
 将链表中的下一个元素与栈中再弹出的元素比较，直至链表到尾。这时若栈是空栈，则得出链表中心
 对称的结论；否则，当链表中的一个元素与栈中弹出元素不等时，结论为链表非中心对称，结束算法
 的执行。
 ------------------------------------------------------------------------*/
int dc(NodePointer L, int n) {
    // L是带头结点的n个元素单链表，本算法判断链表是否是中心对称
    int i;
    char s[n / 2];          // s字符栈
    auto p = L->next;       // p是链表的工作指针，指向待处理的当前元素
    for (i = 0; i < n / 2; i++) {   // 链表前一半元素进栈
        s[i] = p->data;
        p = p->next;
    }
    i--;                // 恢复最后的i值
    if (n % 2 == 1)     // 若n是奇数，后移过中心结点
        p = p->next;
    while (p != nullptr && s[i] == p->data) {       // 检测是否中心对称
        i--;        // i充当栈顶指针
        p = p->next;
    }
    if (i == -1)            // 栈为空栈
        return 1;       // 链表中心对称
    else
        return 0;        // 链表不中心对称
}

/*-------------------------------------------------------------------------
 5. 设有两个栈s1、s2都采用顺序栈方式，并共享一个存储区[0, ..., maxsize - 1]，为了尽量
 利用空间，减少溢出的可能，可采用栈顶相向、迎面增长的存储方式。试设计s1、s2有关入栈和出栈
 的操作算法。

 算法思想: 两个栈共享向量空间，将两个栈的栈底设在向量两端，初始时，s1栈顶指针为-1，s2栈
 顶指针为maxsize。两个栈顶指针相邻时为栈满。两个栈顶相向、迎面增长，栈顶指针指向栈顶元素。
 ------------------------------------------------------------------------*/
const int maxsize = 100;        // 两个栈共享顺序存储空间所能达到的最多元素数 初始化为100

struct stk {
    ElementType stack[maxsize];    // 栈空间
    int top[2];                     // top为两个栈顶指针
};

stk s;
/*-------------------------------------------------------------------------
 本题的关键在于，两个栈入栈和退栈时栈顶指针的计算。s1栈是通常意义下的栈；而s2栈入栈操作
 时，其栈顶指针左移(减1)，退栈时，栈顶指针右移(加1)。
 ------------------------------------------------------------------------*/

// 1) 入栈操作
int push(int i, ElementType x) {
    // 入栈操作。i为栈号，i=0表示左边的s1栈，i=1表示右边的s2栈，x是入栈元素
    // 入栈成功返回1，否则返回0
    if (i < 0 || i > 1) {
        printf("栈号输入不对");
        exit(1);
    }
    if (s.top[1] - s.top[0] == 1) {
        printf("栈已满\n");
        return 0;
    }
    if (i == 0) {
        s.stack[++s.top[0]] = x;
        return 1;
    } else {
        s.stack[++s.top[1]] = x;
        return 1;
    }
}

// 2) 退栈操作
ElementType pop(int i) {
    // 退栈算法。i代表栈号，i=0时为s1栈，i=1时为s2栈
    // 退栈成功返回退栈元素，否则返回-1
    if (i < 0 || i > 1) {
        printf("栈号输入错误\n");
        exit(1);
    }
    if (i == 0) {
        if (s.top[0] == -1) {
            printf("栈空\n");
            return -1;
        } else return s.stack[s.top[0]--];
    } else {
        if (s.top[1] == maxsize) {
            printf("栈空\n");
            return -1;
        } else return s.stack[s.top[1]++];
    }
}


